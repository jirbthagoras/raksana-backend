// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package repositories

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const appendHistry = `-- name: AppendHistry :exec
INSERT INTO histories(user_id, name, category, type, amount)
VALUES($1, $2, $3, $4, $5)
`

type AppendHistryParams struct {
	UserID   int64
	Name     string
	Category string
	Type     string
	Amount   int32
}

func (q *Queries) AppendHistry(ctx context.Context, arg AppendHistryParams) error {
	_, err := q.db.Exec(ctx, appendHistry,
		arg.UserID,
		arg.Name,
		arg.Category,
		arg.Type,
		arg.Amount,
	)
	return err
}

const attend = `-- name: Attend :exec
UPDATE attendances
SET attended = true
WHERE id = $1
`

func (q *Queries) Attend(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, attend, id)
	return err
}

const checkParticipation = `-- name: CheckParticipation :one
SELECT
COUNT (*) FILTER (WHERE user_id = $1 AND challenge_id = $2)
FROM participations
`

type CheckParticipationParams struct {
	UserID      int64
	ChallengeID int64
}

func (q *Queries) CheckParticipation(ctx context.Context, arg CheckParticipationParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkParticipation, arg.UserID, arg.ChallengeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const completePacket = `-- name: CompletePacket :exec
UPDATE packets
SET completed = true
WHERE id = $1
`

func (q *Queries) CompletePacket(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, completePacket, id)
	return err
}

const completeTask = `-- name: CompleteTask :one
UPDATE tasks
SET completed = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $2
  AND DATE(created_at) = CURRENT_DATE
RETURNING id, habit_id, user_id, packet_id, name, description, difficulty, completed, created_at, updated_at
`

type CompleteTaskParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) CompleteTask(ctx context.Context, arg CompleteTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, completeTask, arg.ID, arg.UserID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.HabitID,
		&i.UserID,
		&i.PacketID,
		&i.Name,
		&i.Description,
		&i.Difficulty,
		&i.Completed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countPacketTasks = `-- name: CountPacketTasks :one
SELECT
  COUNT(*) FILTER (WHERE completed = true) AS completed_task,
  COUNT(*) as assigned_task
FROM tasks
WHERE packet_id = $1 AND user_id = $2
`

type CountPacketTasksParams struct {
	PacketID int64
	UserID   int64
}

type CountPacketTasksRow struct {
	CompletedTask int64
	AssignedTask  int64
}

func (q *Queries) CountPacketTasks(ctx context.Context, arg CountPacketTasksParams) (CountPacketTasksRow, error) {
	row := q.db.QueryRow(ctx, countPacketTasks, arg.PacketID, arg.UserID)
	var i CountPacketTasksRow
	err := row.Scan(&i.CompletedTask, &i.AssignedTask)
	return i, err
}

const countQuestContributors = `-- name: CountQuestContributors :many
SELECT
  u.id AS id,
  u.username AS username
FROM contributions c
JOIN users u ON c.user_id = u.id
WHERE quest_id = $1
`

type CountQuestContributorsRow struct {
	ID       int64
	Username string
}

func (q *Queries) CountQuestContributors(ctx context.Context, questID int64) ([]CountQuestContributorsRow, error) {
	rows, err := q.db.Query(ctx, countQuestContributors, questID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountQuestContributorsRow
	for rows.Next() {
		var i CountQuestContributorsRow
		if err := rows.Scan(&i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countUserActivePackets = `-- name: CountUserActivePackets :one
SELECT COUNT(*) FROM packets 
WHERE user_id = $1 AND completed = false
`

func (q *Queries) CountUserActivePackets(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserActivePackets, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserTask = `-- name: CountUserTask :one
SELECT 
  COUNT (*) as assigned_task,
  COUNT (*) FILTER (WHERE completed = true) as completed_task
FROM tasks
WHERE user_id = $1
`

type CountUserTaskRow struct {
	AssignedTask  int64
	CompletedTask int64
}

func (q *Queries) CountUserTask(ctx context.Context, userID int64) (CountUserTaskRow, error) {
	row := q.db.QueryRow(ctx, countUserTask, userID)
	var i CountUserTaskRow
	err := row.Scan(&i.AssignedTask, &i.CompletedTask)
	return i, err
}

const createAttendance = `-- name: CreateAttendance :one
INSERT INTO attendances(user_id, event_id, contact_number)
VALUES ($1, $2, $3)
RETURNING id, user_id, event_id, attended, contact_number, created_at, attended_at
`

type CreateAttendanceParams struct {
	UserID        int64
	EventID       int64
	ContactNumber string
}

func (q *Queries) CreateAttendance(ctx context.Context, arg CreateAttendanceParams) (Attendance, error) {
	row := q.db.QueryRow(ctx, createAttendance, arg.UserID, arg.EventID, arg.ContactNumber)
	var i Attendance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventID,
		&i.Attended,
		&i.ContactNumber,
		&i.CreatedAt,
		&i.AttendedAt,
	)
	return i, err
}

const createClaimed = `-- name: CreateClaimed :exec
INSERT INTO claimed(user_id, treasure_id)
VALUES ($1, $2)
`

type CreateClaimedParams struct {
	UserID     int64
	TreasureID int64
}

func (q *Queries) CreateClaimed(ctx context.Context, arg CreateClaimedParams) error {
	_, err := q.db.Exec(ctx, createClaimed, arg.UserID, arg.TreasureID)
	return err
}

const createContributions = `-- name: CreateContributions :one
INSERT INTO contributions(user_id, quest_id)
VALUES ($1, $2)
RETURNING id, quest_id, user_id, created_at
`

type CreateContributionsParams struct {
	UserID  int64
	QuestID int64
}

func (q *Queries) CreateContributions(ctx context.Context, arg CreateContributionsParams) (Contribution, error) {
	row := q.db.QueryRow(ctx, createContributions, arg.UserID, arg.QuestID)
	var i Contribution
	err := row.Scan(
		&i.ID,
		&i.QuestID,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const createGreenprint = `-- name: CreateGreenprint :one
INSERT INTO greenprints(title, item_id, image_key, description, sustainability_score, estimated_time)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, item_id, image_key, title, description, sustainability_score, estimated_time, created_at
`

type CreateGreenprintParams struct {
	Title               string
	ItemID              int64
	ImageKey            string
	Description         string
	SustainabilityScore string
	EstimatedTime       string
}

func (q *Queries) CreateGreenprint(ctx context.Context, arg CreateGreenprintParams) (Greenprint, error) {
	row := q.db.QueryRow(ctx, createGreenprint,
		arg.Title,
		arg.ItemID,
		arg.ImageKey,
		arg.Description,
		arg.SustainabilityScore,
		arg.EstimatedTime,
	)
	var i Greenprint
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.ImageKey,
		&i.Title,
		&i.Description,
		&i.SustainabilityScore,
		&i.EstimatedTime,
		&i.CreatedAt,
	)
	return i, err
}

const createHabit = `-- name: CreateHabit :one
INSERT INTO habits (packet_id, name, description, difficulty, locked, weight)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateHabitParams struct {
	PacketID    int64
	Name        string
	Description string
	Difficulty  string
	Locked      bool
	Weight      int32
}

func (q *Queries) CreateHabit(ctx context.Context, arg CreateHabitParams) (int64, error) {
	row := q.db.QueryRow(ctx, createHabit,
		arg.PacketID,
		arg.Name,
		arg.Description,
		arg.Difficulty,
		arg.Locked,
		arg.Weight,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createItems = `-- name: CreateItems :one
INSERT INTO items(scan_id, user_id, name, description, value)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, scan_id, name, description, value, created_at
`

type CreateItemsParams struct {
	ScanID      int64
	UserID      int64
	Name        string
	Description string
	Value       string
}

func (q *Queries) CreateItems(ctx context.Context, arg CreateItemsParams) (Item, error) {
	row := q.db.QueryRow(ctx, createItems,
		arg.ScanID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Value,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ScanID,
		&i.Name,
		&i.Description,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const createLog = `-- name: CreateLog :one
INSERT INTO logs (user_id, text, is_system, is_private)
VALUES ($1, $2, $3, $4)
RETURNING id, text, is_system, is_private
`

type CreateLogParams struct {
	UserID    int64
	Text      string
	IsSystem  bool
	IsPrivate bool
}

type CreateLogRow struct {
	ID        int64
	Text      string
	IsSystem  bool
	IsPrivate bool
}

func (q *Queries) CreateLog(ctx context.Context, arg CreateLogParams) (CreateLogRow, error) {
	row := q.db.QueryRow(ctx, createLog,
		arg.UserID,
		arg.Text,
		arg.IsSystem,
		arg.IsPrivate,
	)
	var i CreateLogRow
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.IsSystem,
		&i.IsPrivate,
	)
	return i, err
}

const createMaterials = `-- name: CreateMaterials :one
INSERT INTO materials(greenprint_id,name, description, price, quantity)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, description, price, quantity, greenprint_id
`

type CreateMaterialsParams struct {
	GreenprintID int64
	Name         string
	Description  string
	Price        int32
	Quantity     int32
}

func (q *Queries) CreateMaterials(ctx context.Context, arg CreateMaterialsParams) (Material, error) {
	row := q.db.QueryRow(ctx, createMaterials,
		arg.GreenprintID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Quantity,
	)
	var i Material
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Quantity,
		&i.GreenprintID,
	)
	return i, err
}

const createMemory = `-- name: CreateMemory :one
INSERT INTO memories(user_id, file_key, description)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateMemoryParams struct {
	UserID      int64
	FileKey     string
	Description string
}

func (q *Queries) CreateMemory(ctx context.Context, arg CreateMemoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, createMemory, arg.UserID, arg.FileKey, arg.Description)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createMonthlyRecap = `-- name: CreateMonthlyRecap :one
INSERT INTO recaps(user_id, summary, tips, assigned_task, completed_task, completion_rate, growth_rating, type)
VALUES ($1, $2, $3, $4, $5, $6, $7, 'monthly')
RETURNING id
`

type CreateMonthlyRecapParams struct {
	UserID         int64
	Summary        string
	Tips           string
	AssignedTask   int32
	CompletedTask  int32
	CompletionRate string
	GrowthRating   string
}

func (q *Queries) CreateMonthlyRecap(ctx context.Context, arg CreateMonthlyRecapParams) (int64, error) {
	row := q.db.QueryRow(ctx, createMonthlyRecap,
		arg.UserID,
		arg.Summary,
		arg.Tips,
		arg.AssignedTask,
		arg.CompletedTask,
		arg.CompletionRate,
		arg.GrowthRating,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPacket = `-- name: CreatePacket :one
INSERT INTO packets  (user_id, name, target, description, expected_task, task_per_day)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreatePacketParams struct {
	UserID       int64
	Name         string
	Target       string
	Description  string
	ExpectedTask int32
	TaskPerDay   int32
}

func (q *Queries) CreatePacket(ctx context.Context, arg CreatePacketParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPacket,
		arg.UserID,
		arg.Name,
		arg.Target,
		arg.Description,
		arg.ExpectedTask,
		arg.TaskPerDay,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createParticipation = `-- name: CreateParticipation :one
INSERT INTO participations(challenge_id, user_id, memory_id)
VALUES ($1, $2, $3)
RETURNING id, challenge_id, user_id, memory_id, created_at
`

type CreateParticipationParams struct {
	ChallengeID int64
	UserID      int64
	MemoryID    int64
}

func (q *Queries) CreateParticipation(ctx context.Context, arg CreateParticipationParams) (Participation, error) {
	row := q.db.QueryRow(ctx, createParticipation, arg.ChallengeID, arg.UserID, arg.MemoryID)
	var i Participation
	err := row.Scan(
		&i.ID,
		&i.ChallengeID,
		&i.UserID,
		&i.MemoryID,
		&i.CreatedAt,
	)
	return i, err
}

const createProfile = `-- name: CreateProfile :one
INSERT INTO profiles (user_id, exp_needed)
VALUES ($1, $2)
RETURNING id, user_id, current_exp, exp_needed, level, points, profile_key
`

type CreateProfileParams struct {
	UserID    int64
	ExpNeeded int64
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (Profile, error) {
	row := q.db.QueryRow(ctx, createProfile, arg.UserID, arg.ExpNeeded)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrentExp,
		&i.ExpNeeded,
		&i.Level,
		&i.Points,
		&i.ProfileKey,
	)
	return i, err
}

const createRecapDetails = `-- name: CreateRecapDetails :exec
INSERT INTO recap_details(monthly_recap_id, challenges, events, quests, treasures, longest_streak)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateRecapDetailsParams struct {
	MonthlyRecapID int64
	Challenges     int32
	Events         int32
	Quests         int32
	Treasures      int32
	LongestStreak  int32
}

func (q *Queries) CreateRecapDetails(ctx context.Context, arg CreateRecapDetailsParams) error {
	_, err := q.db.Exec(ctx, createRecapDetails,
		arg.MonthlyRecapID,
		arg.Challenges,
		arg.Events,
		arg.Quests,
		arg.Treasures,
		arg.LongestStreak,
	)
	return err
}

const createScans = `-- name: CreateScans :one
INSERT INTO scans(user_id, title, description, image_key)
VALUES($1, $2, $3, $4)
RETURNING id, user_id, title, description, image_key, created_at
`

type CreateScansParams struct {
	UserID      int64
	Title       string
	Description string
	ImageKey    string
}

func (q *Queries) CreateScans(ctx context.Context, arg CreateScansParams) (Scan, error) {
	row := q.db.QueryRow(ctx, createScans,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.ImageKey,
	)
	var i Scan
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.ImageKey,
		&i.CreatedAt,
	)
	return i, err
}

const createStatistics = `-- name: CreateStatistics :exec
INSERT INTO statistics (user_id)
VALUES ($1)
`

func (q *Queries) CreateStatistics(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, createStatistics, userID)
	return err
}

const createSteps = `-- name: CreateSteps :one
INSERT INTO steps(greenprint_id, description)
VALUES ($1, $2)
RETURNING id, greenprint_id, description, created_at
`

type CreateStepsParams struct {
	GreenprintID int64
	Description  string
}

func (q *Queries) CreateSteps(ctx context.Context, arg CreateStepsParams) (Step, error) {
	row := q.db.QueryRow(ctx, createSteps, arg.GreenprintID, arg.Description)
	var i Step
	err := row.Scan(
		&i.ID,
		&i.GreenprintID,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks(habit_id, user_id, packet_id, name, description, difficulty)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, habit_id, user_id, packet_id, name, description, difficulty, completed, created_at, updated_at
`

type CreateTaskParams struct {
	HabitID     int64
	UserID      int64
	PacketID    int64
	Name        string
	Description string
	Difficulty  string
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.HabitID,
		arg.UserID,
		arg.PacketID,
		arg.Name,
		arg.Description,
		arg.Difficulty,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.HabitID,
		&i.UserID,
		&i.PacketID,
		&i.Name,
		&i.Description,
		&i.Difficulty,
		&i.Completed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTools = `-- name: CreateTools :one
INSERT INTO tools(greenprint_id, name, description, price)
VALUES($1, $2, $3, $4)
RETURNING id, greenprint_id, name, description, price, created_at
`

type CreateToolsParams struct {
	GreenprintID int64
	Name         string
	Description  string
	Price        int32
}

func (q *Queries) CreateTools(ctx context.Context, arg CreateToolsParams) (Tool, error) {
	row := q.db.QueryRow(ctx, createTools,
		arg.GreenprintID,
		arg.Name,
		arg.Description,
		arg.Price,
	)
	var i Tool
	err := row.Scan(
		&i.ID,
		&i.GreenprintID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, username, email, password)
VALUES ($1, $2, $3, $4)
RETURNING id, username, email
`

type CreateUserParams struct {
	Name     string
	Username string
	Email    string
	Password string
}

type CreateUserRow struct {
	ID       int64
	Username string
	Email    string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Username,
		arg.Email,
		arg.Password,
	)
	var i CreateUserRow
	err := row.Scan(&i.ID, &i.Username, &i.Email)
	return i, err
}

const createWeeklyRecap = `-- name: CreateWeeklyRecap :exec
INSERT INTO recaps(user_id, summary, tips, assigned_task, completed_task, completion_rate, growth_rating, type)
VALUES ($1, $2, $3, $4, $5, $6, $7, 'weekly')
`

type CreateWeeklyRecapParams struct {
	UserID         int64
	Summary        string
	Tips           string
	AssignedTask   int32
	CompletedTask  int32
	CompletionRate string
	GrowthRating   string
}

func (q *Queries) CreateWeeklyRecap(ctx context.Context, arg CreateWeeklyRecapParams) error {
	_, err := q.db.Exec(ctx, createWeeklyRecap,
		arg.UserID,
		arg.Summary,
		arg.Tips,
		arg.AssignedTask,
		arg.CompletedTask,
		arg.CompletionRate,
		arg.GrowthRating,
	)
	return err
}

const deactivateTreasure = `-- name: DeactivateTreasure :exec
UPDATE treasures
SET claimed = true
WHERE id = $1
`

func (q *Queries) DeactivateTreasure(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deactivateTreasure, id)
	return err
}

const deleteMemory = `-- name: DeleteMemory :one
DELETE FROM memories
WHERE id = $1 AND user_id = $2
RETURNING file_key
`

type DeleteMemoryParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteMemory(ctx context.Context, arg DeleteMemoryParams) (string, error) {
	row := q.db.QueryRow(ctx, deleteMemory, arg.ID, arg.UserID)
	var file_key string
	err := row.Scan(&file_key)
	return file_key, err
}

const finsihQuest = `-- name: FinsihQuest :exec
UPDATE quests
SET finished = true
WHERE id = $1
`

func (q *Queries) FinsihQuest(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, finsihQuest, id)
	return err
}

const getAllChallenges = `-- name: GetAllChallenges :many
SELECT 
c.id AS challenge_id,
c.day,
c.difficulty,
d.id AS detail_id,
d.name,
d.description,
d.point_gain,
d.created_at,
d.updated_at
FROM challenges c
JOIN details d ON c.detail_id = d.id
ORDER BY d.created_at DESC
`

type GetAllChallengesRow struct {
	ChallengeID int64
	Day         int32
	Difficulty  string
	DetailID    int64
	Name        string
	Description string
	PointGain   int64
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) GetAllChallenges(ctx context.Context) ([]GetAllChallengesRow, error) {
	rows, err := q.db.Query(ctx, getAllChallenges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllChallengesRow
	for rows.Next() {
		var i GetAllChallengesRow
		if err := rows.Scan(
			&i.ChallengeID,
			&i.Day,
			&i.Difficulty,
			&i.DetailID,
			&i.Name,
			&i.Description,
			&i.PointGain,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllClaimedTreasure = `-- name: GetAllClaimedTreasure :many
SELECT 
  t.id AS id,
  t.name AS name,
  c.created_at AS claimed_at,
  t.point_gain AS point_gain
FROM claimed c
JOIN treasures t ON c.treasure_id = t.id
WHERE c.user_id = $1
ORDER BY c.created_at DESC
`

type GetAllClaimedTreasureRow struct {
	ID        int64
	Name      string
	ClaimedAt pgtype.Timestamp
	PointGain int64
}

func (q *Queries) GetAllClaimedTreasure(ctx context.Context, userID int64) ([]GetAllClaimedTreasureRow, error) {
	rows, err := q.db.Query(ctx, getAllClaimedTreasure, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllClaimedTreasureRow
	for rows.Next() {
		var i GetAllClaimedTreasureRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ClaimedAt,
			&i.PointGain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllEvents = `-- name: GetAllEvents :many
SELECT 
    e.id,
    e.detail_id,
    e.code_id,
    e.location,
    e.latitude,
    e.longitude,
    e.contact,
    e.starts_at,
    e.ends_at,
    e.cover_key,
    d.name AS detail_name,
    d.description AS detail_description,
    d.point_gain,
    d.created_at AS detail_created_at,
    d.updated_at AS detail_updated_at,
    (e.ends_at < NOW()) AS ended
FROM events e
JOIN details d ON e.detail_id = d.id
ORDER BY e.starts_at ASC
`

type GetAllEventsRow struct {
	ID                int64
	DetailID          int64
	CodeID            string
	Location          string
	Latitude          float64
	Longitude         float64
	Contact           string
	StartsAt          pgtype.Timestamp
	EndsAt            pgtype.Timestamp
	CoverKey          pgtype.Text
	DetailName        string
	DetailDescription string
	PointGain         int64
	DetailCreatedAt   pgtype.Timestamp
	DetailUpdatedAt   pgtype.Timestamp
	Ended             bool
}

func (q *Queries) GetAllEvents(ctx context.Context) ([]GetAllEventsRow, error) {
	rows, err := q.db.Query(ctx, getAllEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllEventsRow
	for rows.Next() {
		var i GetAllEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.DetailID,
			&i.CodeID,
			&i.Location,
			&i.Latitude,
			&i.Longitude,
			&i.Contact,
			&i.StartsAt,
			&i.EndsAt,
			&i.CoverKey,
			&i.DetailName,
			&i.DetailDescription,
			&i.PointGain,
			&i.DetailCreatedAt,
			&i.DetailUpdatedAt,
			&i.Ended,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMonthlyRecapsWithDetails = `-- name: GetAllMonthlyRecapsWithDetails :many
SELECT r.id            AS recap_id,
       r.user_id,
       r.summary,
       r.tips,
       r.assigned_task,
       r.completed_task,
       r.completion_rate,
       r.growth_rating,
       r.type,
       r.created_at    AS recap_created_at,
       d.id            AS detail_id,
       d.challenges,
       d.events,
       d.quests,
       d.treasures,
       d.longest_streak,
       d.created_at    AS detail_created_at
FROM recaps r
LEFT JOIN recap_details d 
       ON d.monthly_recap_id = r.id
WHERE r.user_id = $1
  AND r.type = 'monthly'
ORDER BY r.created_at DESC
`

type GetAllMonthlyRecapsWithDetailsRow struct {
	RecapID         int64
	UserID          int64
	Summary         string
	Tips            string
	AssignedTask    int32
	CompletedTask   int32
	CompletionRate  string
	GrowthRating    string
	Type            string
	RecapCreatedAt  pgtype.Timestamp
	DetailID        pgtype.Int8
	Challenges      pgtype.Int4
	Events          pgtype.Int4
	Quests          pgtype.Int4
	Treasures       pgtype.Int4
	LongestStreak   pgtype.Int4
	DetailCreatedAt pgtype.Timestamp
}

func (q *Queries) GetAllMonthlyRecapsWithDetails(ctx context.Context, userID int64) ([]GetAllMonthlyRecapsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, getAllMonthlyRecapsWithDetails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMonthlyRecapsWithDetailsRow
	for rows.Next() {
		var i GetAllMonthlyRecapsWithDetailsRow
		if err := rows.Scan(
			&i.RecapID,
			&i.UserID,
			&i.Summary,
			&i.Tips,
			&i.AssignedTask,
			&i.CompletedTask,
			&i.CompletionRate,
			&i.GrowthRating,
			&i.Type,
			&i.RecapCreatedAt,
			&i.DetailID,
			&i.Challenges,
			&i.Events,
			&i.Quests,
			&i.Treasures,
			&i.LongestStreak,
			&i.DetailCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPackets = `-- name: GetAllPackets :many
SELECT id, user_id, name, target, description, completed_task, expected_task, task_per_day, completed, created_at FROM packets
WHERE user_id = $1
`

func (q *Queries) GetAllPackets(ctx context.Context, userID int64) ([]Packet, error) {
	rows, err := q.db.Query(ctx, getAllPackets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Packet
	for rows.Next() {
		var i Packet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Target,
			&i.Description,
			&i.CompletedTask,
			&i.ExpectedTask,
			&i.TaskPerDay,
			&i.Completed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUser = `-- name: GetAllUser :many
SELECT
  u.id AS user_id,
  p.level AS level,
  p.profile_key AS profile_key,
  u.username AS username,
  u.email AS email
FROM profiles p
JOIN users u ON p.user_id = u.id
WHERE u.is_admin = false
`

type GetAllUserRow struct {
	UserID     int64
	Level      int32
	ProfileKey string
	Username   string
	Email      string
}

func (q *Queries) GetAllUser(ctx context.Context) ([]GetAllUserRow, error) {
	rows, err := q.db.Query(ctx, getAllUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserRow
	for rows.Next() {
		var i GetAllUserRow
		if err := rows.Scan(
			&i.UserID,
			&i.Level,
			&i.ProfileKey,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserScans = `-- name: GetAllUserScans :many
SELECT id, user_id, title, description, image_key, created_at FROM scans WHERE user_id = $1
`

func (q *Queries) GetAllUserScans(ctx context.Context, userID int64) ([]Scan, error) {
	rows, err := q.db.Query(ctx, getAllUserScans, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scan
	for rows.Next() {
		var i Scan
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.ImageKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceDetails = `-- name: GetAttendanceDetails :one
SELECT
    a.id AS attendance_id,
    a.attended,
    a.created_at AS attended_at,
    a.contact_number,
    e.id AS event_id,
    e.location,
    e.latitude,
    e.longitude,
    e.contact,
    e.starts_at,
    e.ends_at,
    e.cover_key,
    d.id AS detail_id,
    d.name AS detail_name,
    d.description AS detail_description,
    d.point_gain
FROM attendances a
JOIN events e ON a.event_id = e.id
JOIN details d ON e.detail_id = d.id
WHERE a.id = $1
`

type GetAttendanceDetailsRow struct {
	AttendanceID      int64
	Attended          bool
	AttendedAt        pgtype.Timestamp
	ContactNumber     string
	EventID           int64
	Location          string
	Latitude          float64
	Longitude         float64
	Contact           string
	StartsAt          pgtype.Timestamp
	EndsAt            pgtype.Timestamp
	CoverKey          pgtype.Text
	DetailID          int64
	DetailName        string
	DetailDescription string
	PointGain         int64
}

func (q *Queries) GetAttendanceDetails(ctx context.Context, id int64) (GetAttendanceDetailsRow, error) {
	row := q.db.QueryRow(ctx, getAttendanceDetails, id)
	var i GetAttendanceDetailsRow
	err := row.Scan(
		&i.AttendanceID,
		&i.Attended,
		&i.AttendedAt,
		&i.ContactNumber,
		&i.EventID,
		&i.Location,
		&i.Latitude,
		&i.Longitude,
		&i.Contact,
		&i.StartsAt,
		&i.EndsAt,
		&i.CoverKey,
		&i.DetailID,
		&i.DetailName,
		&i.DetailDescription,
		&i.PointGain,
	)
	return i, err
}

const getChallengeWithDetail = `-- name: GetChallengeWithDetail :one
SELECT 
    c.id AS challenge_id,
    c.day,
    c.difficulty,
    d.id AS detail_id,
    d.name,
    d.description,
    d.point_gain,
    d.created_at,
    d.updated_at
FROM challenges c
JOIN details d ON c.detail_id = d.id
ORDER BY created_at DESC
`

type GetChallengeWithDetailRow struct {
	ChallengeID int64
	Day         int32
	Difficulty  string
	DetailID    int64
	Name        string
	Description string
	PointGain   int64
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) GetChallengeWithDetail(ctx context.Context) (GetChallengeWithDetailRow, error) {
	row := q.db.QueryRow(ctx, getChallengeWithDetail)
	var i GetChallengeWithDetailRow
	err := row.Scan(
		&i.ChallengeID,
		&i.Day,
		&i.Difficulty,
		&i.DetailID,
		&i.Name,
		&i.Description,
		&i.PointGain,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChallengeWithDetailById = `-- name: GetChallengeWithDetailById :one
SELECT 
    c.id AS challenge_id,
    c.day,
    c.difficulty,
    d.id AS detail_id,
    d.name,
    d.description,
    d.point_gain,
    d.created_at,
    d.updated_at
FROM challenges c
JOIN details d ON c.detail_id = d.id
WHERE c.id = $1
ORDER BY created_at DESC
`

type GetChallengeWithDetailByIdRow struct {
	ChallengeID int64
	Day         int32
	Difficulty  string
	DetailID    int64
	Name        string
	Description string
	PointGain   int64
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) GetChallengeWithDetailById(ctx context.Context, id int64) (GetChallengeWithDetailByIdRow, error) {
	row := q.db.QueryRow(ctx, getChallengeWithDetailById, id)
	var i GetChallengeWithDetailByIdRow
	err := row.Scan(
		&i.ChallengeID,
		&i.Day,
		&i.Difficulty,
		&i.DetailID,
		&i.Name,
		&i.Description,
		&i.PointGain,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getContributionDetails = `-- name: GetContributionDetails :one
SELECT 
    c.id               AS id,
    c.created_at       AS contribution_date,
    q.code_id,
    q.id AS quest_id,
    q.location,
    q.latitude,
    q.longitude,
    q.max_contributors,
    d.name             AS name,
    d.description      AS description,
    d.point_gain,
    d.created_at       AS created_at
FROM contributions c
JOIN quests q ON c.quest_id = q.id
JOIN details d ON q.detail_id = d.id
WHERE c.id = $1
`

type GetContributionDetailsRow struct {
	ID               int64
	ContributionDate pgtype.Timestamp
	CodeID           string
	QuestID          int64
	Location         string
	Latitude         float64
	Longitude        float64
	MaxContributors  int32
	Name             string
	Description      string
	PointGain        int64
	CreatedAt        pgtype.Timestamp
}

func (q *Queries) GetContributionDetails(ctx context.Context, id int64) (GetContributionDetailsRow, error) {
	row := q.db.QueryRow(ctx, getContributionDetails, id)
	var i GetContributionDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ContributionDate,
		&i.CodeID,
		&i.QuestID,
		&i.Location,
		&i.Latitude,
		&i.Longitude,
		&i.MaxContributors,
		&i.Name,
		&i.Description,
		&i.PointGain,
		&i.CreatedAt,
	)
	return i, err
}

const getEventByCodeId = `-- name: GetEventByCodeId :one
SELECT
  e.id,
  d.name AS name,
  d.description AS description,
  d.point_gain AS point_gain
FROM events e
JOIN details d ON e.detail_id = d.id
WHERE e.code_id = $1
`

type GetEventByCodeIdRow struct {
	ID          int64
	Name        string
	Description string
	PointGain   int64
}

func (q *Queries) GetEventByCodeId(ctx context.Context, codeID string) (GetEventByCodeIdRow, error) {
	row := q.db.QueryRow(ctx, getEventByCodeId, codeID)
	var i GetEventByCodeIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PointGain,
	)
	return i, err
}

const getEventById = `-- name: GetEventById :one
SELECT 
  e.id,
  d.name AS name,
  d.description AS description
FROM events e
JOIN details d ON e.detail_id = d.id
WHERE e.id = $1
`

type GetEventByIdRow struct {
	ID          int64
	Name        string
	Description string
}

func (q *Queries) GetEventById(ctx context.Context, id int64) (GetEventByIdRow, error) {
	row := q.db.QueryRow(ctx, getEventById, id)
	var i GetEventByIdRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getGreenprints = `-- name: GetGreenprints :one
SELECT id, item_id, image_key, title, description, sustainability_score, estimated_time, created_at FROM greenprints
WHERE item_id = $1
`

func (q *Queries) GetGreenprints(ctx context.Context, itemID int64) (Greenprint, error) {
	row := q.db.QueryRow(ctx, getGreenprints, itemID)
	var i Greenprint
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.ImageKey,
		&i.Title,
		&i.Description,
		&i.SustainabilityScore,
		&i.EstimatedTime,
		&i.CreatedAt,
	)
	return i, err
}

const getGreenprintsById = `-- name: GetGreenprintsById :one
SELECT id, item_id, image_key, title, description, sustainability_score, estimated_time, created_at FROM greenprints
WHERE id = $1
`

func (q *Queries) GetGreenprintsById(ctx context.Context, id int64) (Greenprint, error) {
	row := q.db.QueryRow(ctx, getGreenprintsById, id)
	var i Greenprint
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.ImageKey,
		&i.Title,
		&i.Description,
		&i.SustainabilityScore,
		&i.EstimatedTime,
		&i.CreatedAt,
	)
	return i, err
}

const getItemsById = `-- name: GetItemsById :one
SELECT id, user_id, scan_id, name, description, value, created_at FROM items WHERE id = $1
`

func (q *Queries) GetItemsById(ctx context.Context, id int64) (Item, error) {
	row := q.db.QueryRow(ctx, getItemsById, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ScanID,
		&i.Name,
		&i.Description,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const getItemsByScanId = `-- name: GetItemsByScanId :many
SELECT id, user_id, scan_id, name, description, value, created_at FROM items WHERE scan_id = $1
`

func (q *Queries) GetItemsByScanId(ctx context.Context, scanID int64) ([]Item, error) {
	rows, err := q.db.Query(ctx, getItemsByScanId, scanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ScanID,
			&i.Name,
			&i.Description,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastMonthUserHistories = `-- name: GetLastMonthUserHistories :many
SELECT id, user_id, name, type, category, amount, created_at FROM histories
WHERE user_id = $1
AND date_trunc('month', created_at) = date_trunc('month', CURRENT_DATE)
ORDER BY created_at DESC
`

func (q *Queries) GetLastMonthUserHistories(ctx context.Context, userID int64) ([]History, error) {
	rows, err := q.db.Query(ctx, getLastMonthUserHistories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []History
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastMonthUserLogs = `-- name: GetLastMonthUserLogs :many
SELECT id, user_id, text, is_system, is_private, created_at FROM logs
WHERE user_id =  $1
AND date_trunc('month', created_at) = date_trunc('month', CURRENT_DATE)
ORDER BY created_at DESC
`

func (q *Queries) GetLastMonthUserLogs(ctx context.Context, userID int64) ([]Log, error) {
	rows, err := q.db.Query(ctx, getLastMonthUserLogs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.IsSystem,
			&i.IsPrivate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastWeekTasks = `-- name: GetLastWeekTasks :many
SELECT id, habit_id, user_id, packet_id, name, description, difficulty, completed, created_at, updated_at
FROM tasks
WHERE created_at >= NOW() - INTERVAL '7 weeks' AND user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetLastWeekTasks(ctx context.Context, userID int64) ([]Task, error) {
	rows, err := q.db.Query(ctx, getLastWeekTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.HabitID,
			&i.UserID,
			&i.PacketID,
			&i.Name,
			&i.Description,
			&i.Difficulty,
			&i.Completed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMonhtlyRecap = `-- name: GetLatestMonhtlyRecap :one
SELECT 
  id, user_id, summary, tips, assigned_task, completed_task, completion_rate, growth_rating, type, created_at,
  (date_trunc('month', created_at) = date_trunc('month', CURRENT_DATE)) 
           AS is_this_month
FROM recaps
WHERE user_id = $1 AND type = 'monthly'
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestMonhtlyRecapRow struct {
	ID             int64
	UserID         int64
	Summary        string
	Tips           string
	AssignedTask   int32
	CompletedTask  int32
	CompletionRate string
	GrowthRating   string
	Type           string
	CreatedAt      pgtype.Timestamp
	IsThisMonth    bool
}

func (q *Queries) GetLatestMonhtlyRecap(ctx context.Context, userID int64) (GetLatestMonhtlyRecapRow, error) {
	row := q.db.QueryRow(ctx, getLatestMonhtlyRecap, userID)
	var i GetLatestMonhtlyRecapRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Summary,
		&i.Tips,
		&i.AssignedTask,
		&i.CompletedTask,
		&i.CompletionRate,
		&i.GrowthRating,
		&i.Type,
		&i.CreatedAt,
		&i.IsThisMonth,
	)
	return i, err
}

const getLatestRecap = `-- name: GetLatestRecap :one
SELECT id, user_id, summary, tips, assigned_task, completed_task, completion_rate, growth_rating, type, created_at
FROM recaps
WHERE user_id = $1
  AND type = 'weekly'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestRecap(ctx context.Context, userID int64) (Recap, error) {
	row := q.db.QueryRow(ctx, getLatestRecap, userID)
	var i Recap
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Summary,
		&i.Tips,
		&i.AssignedTask,
		&i.CompletedTask,
		&i.CompletionRate,
		&i.GrowthRating,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const getLogs = `-- name: GetLogs :many
SELECT text, created_at, is_system, is_private
FROM logs
WHERE user_id = $1 AND is_private = $2
ORDER BY created_at DESC
`

type GetLogsParams struct {
	UserID    int64
	IsPrivate bool
}

type GetLogsRow struct {
	Text      string
	CreatedAt pgtype.Timestamp
	IsSystem  bool
	IsPrivate bool
}

func (q *Queries) GetLogs(ctx context.Context, arg GetLogsParams) ([]GetLogsRow, error) {
	rows, err := q.db.Query(ctx, getLogs, arg.UserID, arg.IsPrivate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLogsRow
	for rows.Next() {
		var i GetLogsRow
		if err := rows.Scan(
			&i.Text,
			&i.CreatedAt,
			&i.IsSystem,
			&i.IsPrivate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterials = `-- name: GetMaterials :many
SELECT id, name, description, price, quantity, greenprint_id FROM materials
WHERE greenprint_id = $1
`

func (q *Queries) GetMaterials(ctx context.Context, greenprintID int64) ([]Material, error) {
	rows, err := q.db.Query(ctx, getMaterials, greenprintID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Quantity,
			&i.GreenprintID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemoriesByChallengeID = `-- name: GetMemoriesByChallengeID :many
SELECT 
    m.id AS memory_id,
    m.file_key,
    m.description,
    m.created_at AS memory_created_at,
    u.id AS user_id,
    u.name AS user_name,
    u.username,
    u.email
FROM participations p
JOIN memories m ON p.memory_id = m.id
JOIN users u ON m.user_id = u.id
WHERE p.challenge_id = $1
ORDER BY m.created_at DESC
`

type GetMemoriesByChallengeIDRow struct {
	MemoryID        int64
	FileKey         string
	Description     string
	MemoryCreatedAt pgtype.Timestamp
	UserID          int64
	UserName        string
	Username        string
	Email           string
}

func (q *Queries) GetMemoriesByChallengeID(ctx context.Context, challengeID int64) ([]GetMemoriesByChallengeIDRow, error) {
	rows, err := q.db.Query(ctx, getMemoriesByChallengeID, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMemoriesByChallengeIDRow
	for rows.Next() {
		var i GetMemoriesByChallengeIDRow
		if err := rows.Scan(
			&i.MemoryID,
			&i.FileKey,
			&i.Description,
			&i.MemoryCreatedAt,
			&i.UserID,
			&i.UserName,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemoryWithParticipation = `-- name: GetMemoryWithParticipation :many
SELECT 
    m.id AS memory_id,
    m.file_key,
    m.description AS memory_description,
    m.created_at AS memory_created_at,
    u.id AS user_id,
    u.username AS user_name,
    CASE 
        WHEN p.id IS NOT NULL THEN TRUE 
        ELSE FALSE 
    END AS is_participation,
    p.challenge_id,
    c.day,
    c.difficulty,
    d.name AS challenge_name,
    d.point_gain
FROM memories m
JOIN users u ON m.user_id = u.id
LEFT JOIN participations p ON m.id = p.memory_id
LEFT JOIN challenges c ON p.challenge_id = c.id
LEFT JOIN details d ON c.detail_id = d.id
WHERE m.user_id = $1
ORDER BY m.created_at DESC
`

type GetMemoryWithParticipationRow struct {
	MemoryID          int64
	FileKey           string
	MemoryDescription string
	MemoryCreatedAt   pgtype.Timestamp
	UserID            int64
	UserName          string
	IsParticipation   bool
	ChallengeID       pgtype.Int8
	Day               pgtype.Int4
	Difficulty        pgtype.Text
	ChallengeName     pgtype.Text
	PointGain         pgtype.Int8
}

func (q *Queries) GetMemoryWithParticipation(ctx context.Context, userID int64) ([]GetMemoryWithParticipationRow, error) {
	rows, err := q.db.Query(ctx, getMemoryWithParticipation, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMemoryWithParticipationRow
	for rows.Next() {
		var i GetMemoryWithParticipationRow
		if err := rows.Scan(
			&i.MemoryID,
			&i.FileKey,
			&i.MemoryDescription,
			&i.MemoryCreatedAt,
			&i.UserID,
			&i.UserName,
			&i.IsParticipation,
			&i.ChallengeID,
			&i.Day,
			&i.Difficulty,
			&i.ChallengeName,
			&i.PointGain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNearestQuestWithinRadius = `-- name: GetNearestQuestWithinRadius :one
SELECT 
    id,
    clue,
    location,
    latitude,
    longitude,
    earth_distance(
        ll_to_earth($1, $2),
        ll_to_earth(latitude, longitude)
    ) AS distance_meters
FROM quests
WHERE finished = false
  AND earth_distance(
        ll_to_earth($1, $2),
        ll_to_earth(latitude, longitude)
    ) <= $3
ORDER BY distance_meters
LIMIT 1
`

type GetNearestQuestWithinRadiusParams struct {
	LlToEarth   float64
	LlToEarth_2 float64
	Latitude    float64
}

type GetNearestQuestWithinRadiusRow struct {
	ID             int64
	Clue           pgtype.Text
	Location       string
	Latitude       float64
	Longitude      float64
	DistanceMeters float64
}

func (q *Queries) GetNearestQuestWithinRadius(ctx context.Context, arg GetNearestQuestWithinRadiusParams) (GetNearestQuestWithinRadiusRow, error) {
	row := q.db.QueryRow(ctx, getNearestQuestWithinRadius, arg.LlToEarth, arg.LlToEarth_2, arg.Latitude)
	var i GetNearestQuestWithinRadiusRow
	err := row.Scan(
		&i.ID,
		&i.Clue,
		&i.Location,
		&i.Latitude,
		&i.Longitude,
		&i.DistanceMeters,
	)
	return i, err
}

const getPacketDetail = `-- name: GetPacketDetail :one
SELECT 
    p.id AS packet_id,
    p.user_id,
    u.name AS user_name,
    u.username,
    p.name AS packet_name,
    p.target,
    p.description,
    p.completed_task,
    p.expected_task,
    p.task_per_day,
    p.completed,
    p.created_at
FROM packets p
JOIN users u ON u.id = p.user_id
WHERE p.id = $1
`

type GetPacketDetailRow struct {
	PacketID      int64
	UserID        int64
	UserName      string
	Username      string
	PacketName    string
	Target        string
	Description   string
	CompletedTask int32
	ExpectedTask  int32
	TaskPerDay    int32
	Completed     bool
	CreatedAt     pgtype.Timestamp
}

func (q *Queries) GetPacketDetail(ctx context.Context, id int64) (GetPacketDetailRow, error) {
	row := q.db.QueryRow(ctx, getPacketDetail, id)
	var i GetPacketDetailRow
	err := row.Scan(
		&i.PacketID,
		&i.UserID,
		&i.UserName,
		&i.Username,
		&i.PacketName,
		&i.Target,
		&i.Description,
		&i.CompletedTask,
		&i.ExpectedTask,
		&i.TaskPerDay,
		&i.Completed,
		&i.CreatedAt,
	)
	return i, err
}

const getPacketHabits = `-- name: GetPacketHabits :many
SELECT 
  id, packet_id, name, description, difficulty, locked, weight
FROM habits
WHERE packet_id = $1
`

func (q *Queries) GetPacketHabits(ctx context.Context, packetID int64) ([]Habit, error) {
	rows, err := q.db.Query(ctx, getPacketHabits, packetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Habit
	for rows.Next() {
		var i Habit
		if err := rows.Scan(
			&i.ID,
			&i.PacketID,
			&i.Name,
			&i.Description,
			&i.Difficulty,
			&i.Locked,
			&i.Weight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPacketUnlockedHabits = `-- name: GetPacketUnlockedHabits :many
SELECT id, packet_id, name, description, difficulty, locked, weight FROM habits
WHERE packet_id = $1 AND locked = false
`

func (q *Queries) GetPacketUnlockedHabits(ctx context.Context, packetID int64) ([]Habit, error) {
	rows, err := q.db.Query(ctx, getPacketUnlockedHabits, packetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Habit
	for rows.Next() {
		var i Habit
		if err := rows.Scan(
			&i.ID,
			&i.PacketID,
			&i.Name,
			&i.Description,
			&i.Difficulty,
			&i.Locked,
			&i.Weight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipants = `-- name: GetParticipants :one
SELECT 
  COUNT (*) FILTER (WHERE challenge_id = $1) AS participants
FROM participations
`

func (q *Queries) GetParticipants(ctx context.Context, challengeID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getParticipants, challengeID)
	var participants int64
	err := row.Scan(&participants)
	return participants, err
}

const getQuestByCodeId = `-- name: GetQuestByCodeId :one
SELECT 
  q.id AS id,
  q.location AS location,
  q.max_contributors AS max_contributors,
  q.latitude AS latitude,
  q.longitude AS longitude,
  d.name AS name,
  d.description AS description,
  d.point_gain AS point_gain,
  q.finished
FROM quests q
JOIN details d ON q.detail_id = d.id
WHERE q.code_id = $1
`

type GetQuestByCodeIdRow struct {
	ID              int64
	Location        string
	MaxContributors int32
	Latitude        float64
	Longitude       float64
	Name            string
	Description     string
	PointGain       int64
	Finished        bool
}

func (q *Queries) GetQuestByCodeId(ctx context.Context, codeID string) (GetQuestByCodeIdRow, error) {
	row := q.db.QueryRow(ctx, getQuestByCodeId, codeID)
	var i GetQuestByCodeIdRow
	err := row.Scan(
		&i.ID,
		&i.Location,
		&i.MaxContributors,
		&i.Latitude,
		&i.Longitude,
		&i.Name,
		&i.Description,
		&i.PointGain,
		&i.Finished,
	)
	return i, err
}

const getSteps = `-- name: GetSteps :many
SELECT id, greenprint_id, description, created_at FROM steps
WHERE greenprint_id = $1
`

func (q *Queries) GetSteps(ctx context.Context, greenprintID int64) ([]Step, error) {
	rows, err := q.db.Query(ctx, getSteps, greenprintID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Step
	for rows.Next() {
		var i Step
		if err := rows.Scan(
			&i.ID,
			&i.GreenprintID,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskById = `-- name: GetTaskById :one
SELECT id, habit_id, user_id, packet_id, name, description, difficulty, completed, created_at, updated_at FROM tasks
WHERE id = $1
`

func (q *Queries) GetTaskById(ctx context.Context, id int64) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskById, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.HabitID,
		&i.UserID,
		&i.PacketID,
		&i.Name,
		&i.Description,
		&i.Difficulty,
		&i.Completed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTodayChallenge = `-- name: GetTodayChallenge :one
SELECT 
    c.id AS challenge_id,
    c.day,
    c.difficulty,
    d.id AS detail_id,
    d.name,
    d.description,
    d.point_gain,
    d.created_at,
    d.updated_at
FROM challenges c
JOIN details d ON c.detail_id = d.id
ORDER BY d.created_at DESC
LIMIT 1
`

type GetTodayChallengeRow struct {
	ChallengeID int64
	Day         int32
	Difficulty  string
	DetailID    int64
	Name        string
	Description string
	PointGain   int64
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) GetTodayChallenge(ctx context.Context) (GetTodayChallengeRow, error) {
	row := q.db.QueryRow(ctx, getTodayChallenge)
	var i GetTodayChallengeRow
	err := row.Scan(
		&i.ChallengeID,
		&i.Day,
		&i.Difficulty,
		&i.DetailID,
		&i.Name,
		&i.Description,
		&i.PointGain,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTodayTasks = `-- name: GetTodayTasks :many
SELECT id, habit_id, user_id, packet_id, name, description, difficulty, completed, created_at, updated_at
FROM tasks
WHERE user_id = $1
  AND DATE(created_at) = CURRENT_DATE
ORDER BY id
`

func (q *Queries) GetTodayTasks(ctx context.Context, userID int64) ([]Task, error) {
	rows, err := q.db.Query(ctx, getTodayTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.HabitID,
			&i.UserID,
			&i.PacketID,
			&i.Name,
			&i.Description,
			&i.Difficulty,
			&i.Completed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTools = `-- name: GetTools :many
SELECT id, greenprint_id, name, description, price, created_at FROM tools
WHERE greenprint_id = $1
`

func (q *Queries) GetTools(ctx context.Context, greenprintID int64) ([]Tool, error) {
	rows, err := q.db.Query(ctx, getTools, greenprintID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tool
	for rows.Next() {
		var i Tool
		if err := rows.Scan(
			&i.ID,
			&i.GreenprintID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreasureByCodeId = `-- name: GetTreasureByCodeId :one
SELECT id, name, point_gain, code_id, claimed, created_at, updated_at FROM treasures
WHERE code_id = $1 AND claimed = false
`

func (q *Queries) GetTreasureByCodeId(ctx context.Context, codeID string) (Treasure, error) {
	row := q.db.QueryRow(ctx, getTreasureByCodeId, codeID)
	var i Treasure
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PointGain,
		&i.CodeID,
		&i.Claimed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUncompletedQuestByCodeId = `-- name: GetUncompletedQuestByCodeId :one
SELECT 
  q.id AS id,
  q.location AS location,
  q.max_contributors AS max_contributors,
  q.latitude AS latitude,
  q.longitude AS longitude,
  d.name AS name,
  d.description AS description,
  d.point_gain AS point_gain
FROM quests q
JOIN details d ON q.detail_id = d.id
WHERE code_id = $1 AND finished = false
`

type GetUncompletedQuestByCodeIdRow struct {
	ID              int64
	Location        string
	MaxContributors int32
	Latitude        float64
	Longitude       float64
	Name            string
	Description     string
	PointGain       int64
}

func (q *Queries) GetUncompletedQuestByCodeId(ctx context.Context, codeID string) (GetUncompletedQuestByCodeIdRow, error) {
	row := q.db.QueryRow(ctx, getUncompletedQuestByCodeId, codeID)
	var i GetUncompletedQuestByCodeIdRow
	err := row.Scan(
		&i.ID,
		&i.Location,
		&i.MaxContributors,
		&i.Latitude,
		&i.Longitude,
		&i.Name,
		&i.Description,
		&i.PointGain,
	)
	return i, err
}

const getUserActivePackets = `-- name: GetUserActivePackets :one
SELECT id, user_id, name, target, description, completed_task, expected_task, task_per_day, completed, created_at FROM packets
WHERE user_id = $1 AND completed = false
`

func (q *Queries) GetUserActivePackets(ctx context.Context, userID int64) (Packet, error) {
	row := q.db.QueryRow(ctx, getUserActivePackets, userID)
	var i Packet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Target,
		&i.Description,
		&i.CompletedTask,
		&i.ExpectedTask,
		&i.TaskPerDay,
		&i.Completed,
		&i.CreatedAt,
	)
	return i, err
}

const getUserAttendance = `-- name: GetUserAttendance :one
SELECT 
    a.id AS attendance_id,
    a.created_at AS attended_at,
    a.contact_number,
    e.id AS event_id,
    e.location,
    e.latitude,
    e.longitude,
    e.contact,
    e.starts_at,
    e.ends_at,
    a.attended,
    e.cover_key,
    d.id AS detail_id,
    d.name AS detail_name,
    d.description AS detail_description,
    d.point_gain,
    a.created_at
FROM attendances a
JOIN events e ON a.event_id = e.id
JOIN details d ON e.detail_id = d.id
WHERE a.id = $1
`

type GetUserAttendanceRow struct {
	AttendanceID      int64
	AttendedAt        pgtype.Timestamp
	ContactNumber     string
	EventID           int64
	Location          string
	Latitude          float64
	Longitude         float64
	Contact           string
	StartsAt          pgtype.Timestamp
	EndsAt            pgtype.Timestamp
	Attended          bool
	CoverKey          pgtype.Text
	DetailID          int64
	DetailName        string
	DetailDescription string
	PointGain         int64
	CreatedAt         pgtype.Timestamp
}

func (q *Queries) GetUserAttendance(ctx context.Context, id int64) (GetUserAttendanceRow, error) {
	row := q.db.QueryRow(ctx, getUserAttendance, id)
	var i GetUserAttendanceRow
	err := row.Scan(
		&i.AttendanceID,
		&i.AttendedAt,
		&i.ContactNumber,
		&i.EventID,
		&i.Location,
		&i.Latitude,
		&i.Longitude,
		&i.Contact,
		&i.StartsAt,
		&i.EndsAt,
		&i.Attended,
		&i.CoverKey,
		&i.DetailID,
		&i.DetailName,
		&i.DetailDescription,
		&i.PointGain,
		&i.CreatedAt,
	)
	return i, err
}

const getUserAttendanceById = `-- name: GetUserAttendanceById :one
SELECT 
    a.id AS attendance_id,
    a.created_at AS attended_at,
    a.contact_number,
    e.id AS event_id,
    e.location,
    e.latitude,
    e.longitude,
    e.contact,
    e.starts_at,
    e.ends_at,
    a.attended,
    e.cover_key,
    d.name AS name,
    d.description AS description,
    d.point_gain
FROM attendances a
JOIN events e ON a.event_id = e.id
JOIN details d ON e.detail_id = d.id
WHERE a.id = $1
`

type GetUserAttendanceByIdRow struct {
	AttendanceID  int64
	AttendedAt    pgtype.Timestamp
	ContactNumber string
	EventID       int64
	Location      string
	Latitude      float64
	Longitude     float64
	Contact       string
	StartsAt      pgtype.Timestamp
	EndsAt        pgtype.Timestamp
	Attended      bool
	CoverKey      pgtype.Text
	Name          string
	Description   string
	PointGain     int64
}

func (q *Queries) GetUserAttendanceById(ctx context.Context, id int64) (GetUserAttendanceByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserAttendanceById, id)
	var i GetUserAttendanceByIdRow
	err := row.Scan(
		&i.AttendanceID,
		&i.AttendedAt,
		&i.ContactNumber,
		&i.EventID,
		&i.Location,
		&i.Latitude,
		&i.Longitude,
		&i.Contact,
		&i.StartsAt,
		&i.EndsAt,
		&i.Attended,
		&i.CoverKey,
		&i.Name,
		&i.Description,
		&i.PointGain,
	)
	return i, err
}

const getUserAttendanceByUserId = `-- name: GetUserAttendanceByUserId :one
SELECT 
    a.id AS attendance_id,
    a.created_at AS attended_at,
    a.contact_number,
    e.id AS event_id,
    e.location,
    e.latitude,
    e.longitude,
    e.contact,
    e.starts_at,
    e.ends_at,
    a.attended,
    e.cover_key,
    d.id AS detail_id,
    d.name AS detail_name,
    d.description AS detail_description,
    d.point_gain,
    a.created_at
FROM attendances a
JOIN events e ON a.event_id = e.id
JOIN details d ON e.detail_id = d.id
WHERE a.user_id = $1 AND e.id = $2
`

type GetUserAttendanceByUserIdParams struct {
	UserID int64
	ID     int64
}

type GetUserAttendanceByUserIdRow struct {
	AttendanceID      int64
	AttendedAt        pgtype.Timestamp
	ContactNumber     string
	EventID           int64
	Location          string
	Latitude          float64
	Longitude         float64
	Contact           string
	StartsAt          pgtype.Timestamp
	EndsAt            pgtype.Timestamp
	Attended          bool
	CoverKey          pgtype.Text
	DetailID          int64
	DetailName        string
	DetailDescription string
	PointGain         int64
	CreatedAt         pgtype.Timestamp
}

func (q *Queries) GetUserAttendanceByUserId(ctx context.Context, arg GetUserAttendanceByUserIdParams) (GetUserAttendanceByUserIdRow, error) {
	row := q.db.QueryRow(ctx, getUserAttendanceByUserId, arg.UserID, arg.ID)
	var i GetUserAttendanceByUserIdRow
	err := row.Scan(
		&i.AttendanceID,
		&i.AttendedAt,
		&i.ContactNumber,
		&i.EventID,
		&i.Location,
		&i.Latitude,
		&i.Longitude,
		&i.Contact,
		&i.StartsAt,
		&i.EndsAt,
		&i.Attended,
		&i.CoverKey,
		&i.DetailID,
		&i.DetailName,
		&i.DetailDescription,
		&i.PointGain,
		&i.CreatedAt,
	)
	return i, err
}

const getUserAttendances = `-- name: GetUserAttendances :many
SELECT 
    a.id AS attendance_id,
    a.created_at AS attended_at,
    a.contact_number,
    e.id AS event_id,
    e.location,
    e.latitude,
    e.longitude,
    e.contact,
    e.starts_at,
    e.ends_at,
    a.attended,
    e.cover_key,
    d.id AS detail_id,
    d.name AS detail_name,
    d.description AS detail_description,
    d.point_gain
FROM attendances a
JOIN events e ON a.event_id = e.id
JOIN details d ON e.detail_id = d.id
WHERE a.user_id = $1
ORDER BY a.created_at DESC
`

type GetUserAttendancesRow struct {
	AttendanceID      int64
	AttendedAt        pgtype.Timestamp
	ContactNumber     string
	EventID           int64
	Location          string
	Latitude          float64
	Longitude         float64
	Contact           string
	StartsAt          pgtype.Timestamp
	EndsAt            pgtype.Timestamp
	Attended          bool
	CoverKey          pgtype.Text
	DetailID          int64
	DetailName        string
	DetailDescription string
	PointGain         int64
}

func (q *Queries) GetUserAttendances(ctx context.Context, userID int64) ([]GetUserAttendancesRow, error) {
	rows, err := q.db.Query(ctx, getUserAttendances, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAttendancesRow
	for rows.Next() {
		var i GetUserAttendancesRow
		if err := rows.Scan(
			&i.AttendanceID,
			&i.AttendedAt,
			&i.ContactNumber,
			&i.EventID,
			&i.Location,
			&i.Latitude,
			&i.Longitude,
			&i.Contact,
			&i.StartsAt,
			&i.EndsAt,
			&i.Attended,
			&i.CoverKey,
			&i.DetailID,
			&i.DetailName,
			&i.DetailDescription,
			&i.PointGain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password, is_admin 
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID       int64
	Username string
	Email    string
	Password string
	IsAdmin  bool
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.IsAdmin,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, email, password, is_admin
FROM users
WHERE id = $1
`

type GetUserByIdRow struct {
	ID       int64
	Username string
	Email    string
	Password string
	IsAdmin  bool
}

func (q *Queries) GetUserById(ctx context.Context, id int64) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.IsAdmin,
	)
	return i, err
}

const getUserContributions = `-- name: GetUserContributions :many
SELECT 
    c.id               AS contribution_id,
    d.name As name,
    d.description AS description,
    q.latitude,
    q.longitude,
    d.point_gain AS point_gain
FROM contributions c
JOIN quests q ON c.quest_id = q.id
JOIN details d ON q.detail_id = d.id
WHERE c.user_id = $1
ORDER BY c.created_at DESC
`

type GetUserContributionsRow struct {
	ContributionID int64
	Name           string
	Description    string
	Latitude       float64
	Longitude      float64
	PointGain      int64
}

func (q *Queries) GetUserContributions(ctx context.Context, userID int64) ([]GetUserContributionsRow, error) {
	rows, err := q.db.Query(ctx, getUserContributions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserContributionsRow
	for rows.Next() {
		var i GetUserContributionsRow
		if err := rows.Scan(
			&i.ContributionID,
			&i.Name,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.PointGain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserHistories = `-- name: GetUserHistories :many
SELECT id, user_id, name, type, category, amount, created_at FROM histories
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetUserHistories(ctx context.Context, userID int64) ([]History, error) {
	rows, err := q.db.Query(ctx, getUserHistories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []History
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPendingAttendances = `-- name: GetUserPendingAttendances :many
SELECT 
    a.id AS attendance_id,
    e.id AS event_id,
    a.created_at AS registered_at,
    a.contact_number,
    e.location,
    e.latitude,
    e.longitude,
    e.contact,
    e.starts_at,
    e.ends_at,
    e.cover_key,
    d.name AS detail_name,
    d.description AS detail_description,
    d.point_gain
FROM attendances a
JOIN events e ON a.event_id = e.id
JOIN details d ON e.detail_id = d.id
WHERE a.user_id = $1 AND a.attended = false
`

type GetUserPendingAttendancesRow struct {
	AttendanceID      int64
	EventID           int64
	RegisteredAt      pgtype.Timestamp
	ContactNumber     string
	Location          string
	Latitude          float64
	Longitude         float64
	Contact           string
	StartsAt          pgtype.Timestamp
	EndsAt            pgtype.Timestamp
	CoverKey          pgtype.Text
	DetailName        string
	DetailDescription string
	PointGain         int64
}

func (q *Queries) GetUserPendingAttendances(ctx context.Context, userID int64) ([]GetUserPendingAttendancesRow, error) {
	rows, err := q.db.Query(ctx, getUserPendingAttendances, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPendingAttendancesRow
	for rows.Next() {
		var i GetUserPendingAttendancesRow
		if err := rows.Scan(
			&i.AttendanceID,
			&i.EventID,
			&i.RegisteredAt,
			&i.ContactNumber,
			&i.Location,
			&i.Latitude,
			&i.Longitude,
			&i.Contact,
			&i.StartsAt,
			&i.EndsAt,
			&i.CoverKey,
			&i.DetailName,
			&i.DetailDescription,
			&i.PointGain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT p.id, p.user_id, p.current_exp, p.exp_needed, p.level, p.points, p.profile_key
FROM profiles p
JOIN users u ON p.user_id = u.id
WHERE p.user_id = $1
`

func (q *Queries) GetUserProfile(ctx context.Context, userID int64) (Profile, error) {
	row := q.db.QueryRow(ctx, getUserProfile, userID)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrentExp,
		&i.ExpNeeded,
		&i.Level,
		&i.Points,
		&i.ProfileKey,
	)
	return i, err
}

const getUserProfileStatistic = `-- name: GetUserProfileStatistic :one
SELECT 
    u.id AS user_id,
    u.name,
    u.username,
    u.email,
    p.current_exp,
    p.exp_needed,
    p.level,
    p.points,
    p.profile_key,
    s.challenges,
    s.events,
    s.quests,
    s.treasures,
    s.longest_streak,
    s.tree_grown
FROM users u
JOIN profiles p ON u.id = p.user_id
JOIN statistics s ON u.id = s.user_id
WHERE u.id = $1
`

type GetUserProfileStatisticRow struct {
	UserID        int64
	Name          string
	Username      string
	Email         string
	CurrentExp    int64
	ExpNeeded     int64
	Level         int32
	Points        int64
	ProfileKey    string
	Challenges    int32
	Events        int32
	Quests        int32
	Treasures     int32
	LongestStreak int32
	TreeGrown     int32
}

func (q *Queries) GetUserProfileStatistic(ctx context.Context, id int64) (GetUserProfileStatisticRow, error) {
	row := q.db.QueryRow(ctx, getUserProfileStatistic, id)
	var i GetUserProfileStatisticRow
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.CurrentExp,
		&i.ExpNeeded,
		&i.Level,
		&i.Points,
		&i.ProfileKey,
		&i.Challenges,
		&i.Events,
		&i.Quests,
		&i.Treasures,
		&i.LongestStreak,
		&i.TreeGrown,
	)
	return i, err
}

const getUserStatistic = `-- name: GetUserStatistic :one
SELECT id, user_id, challenges, events, quests, treasures, longest_streak, tree_grown FROM statistics WHERE user_id = $1
`

func (q *Queries) GetUserStatistic(ctx context.Context, userID int64) (Statistic, error) {
	row := q.db.QueryRow(ctx, getUserStatistic, userID)
	var i Statistic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Challenges,
		&i.Events,
		&i.Quests,
		&i.Treasures,
		&i.LongestStreak,
		&i.TreeGrown,
	)
	return i, err
}

const getWeeklyRecaps = `-- name: GetWeeklyRecaps :many
SELECT id, user_id, summary, tips, assigned_task, completed_task, completion_rate, growth_rating, type, created_at FROM recaps
WHERE user_id = $1 AND type = 'weekly'
ORDER BY created_at DESC
`

func (q *Queries) GetWeeklyRecaps(ctx context.Context, userID int64) ([]Recap, error) {
	rows, err := q.db.Query(ctx, getWeeklyRecaps, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recap
	for rows.Next() {
		var i Recap
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Summary,
			&i.Tips,
			&i.AssignedTask,
			&i.CompletedTask,
			&i.CompletionRate,
			&i.GrowthRating,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const increaseChallengesFieldByOne = `-- name: IncreaseChallengesFieldByOne :one
UPDATE statistics
SET challenges = challenges + 1
WHERE user_id = $1
RETURNING id, user_id, challenges, events, quests, treasures, longest_streak, tree_grown
`

func (q *Queries) IncreaseChallengesFieldByOne(ctx context.Context, userID int64) (Statistic, error) {
	row := q.db.QueryRow(ctx, increaseChallengesFieldByOne, userID)
	var i Statistic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Challenges,
		&i.Events,
		&i.Quests,
		&i.Treasures,
		&i.LongestStreak,
		&i.TreeGrown,
	)
	return i, err
}

const increaseEventsFieldByOne = `-- name: IncreaseEventsFieldByOne :one
UPDATE statistics
SET events = events + 1
WHERE user_id = $1
RETURNING id, user_id, challenges, events, quests, treasures, longest_streak, tree_grown
`

func (q *Queries) IncreaseEventsFieldByOne(ctx context.Context, userID int64) (Statistic, error) {
	row := q.db.QueryRow(ctx, increaseEventsFieldByOne, userID)
	var i Statistic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Challenges,
		&i.Events,
		&i.Quests,
		&i.Treasures,
		&i.LongestStreak,
		&i.TreeGrown,
	)
	return i, err
}

const increaseExp = `-- name: IncreaseExp :one
UPDATE profiles 
SET current_exp = current_exp + $1::int
WHERE user_id = $2::int
RETURNING current_exp, exp_needed, level
`

type IncreaseExpParams struct {
	ExpGain int32
	UserID  int32
}

type IncreaseExpRow struct {
	CurrentExp int64
	ExpNeeded  int64
	Level      int32
}

func (q *Queries) IncreaseExp(ctx context.Context, arg IncreaseExpParams) (IncreaseExpRow, error) {
	row := q.db.QueryRow(ctx, increaseExp, arg.ExpGain, arg.UserID)
	var i IncreaseExpRow
	err := row.Scan(&i.CurrentExp, &i.ExpNeeded, &i.Level)
	return i, err
}

const increasePacketCompletedTask = `-- name: IncreasePacketCompletedTask :exec
UPDATE packets
SET completed_task = completed_task + 1
WHERE id = $1
`

func (q *Queries) IncreasePacketCompletedTask(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, increasePacketCompletedTask, id)
	return err
}

const increaseQuestsFieldByOne = `-- name: IncreaseQuestsFieldByOne :one
UPDATE statistics
SET quests = quests + 1
WHERE user_id = $1
RETURNING id, user_id, challenges, events, quests, treasures, longest_streak, tree_grown
`

func (q *Queries) IncreaseQuestsFieldByOne(ctx context.Context, userID int64) (Statistic, error) {
	row := q.db.QueryRow(ctx, increaseQuestsFieldByOne, userID)
	var i Statistic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Challenges,
		&i.Events,
		&i.Quests,
		&i.Treasures,
		&i.LongestStreak,
		&i.TreeGrown,
	)
	return i, err
}

const increaseTreasuresFieldByOne = `-- name: IncreaseTreasuresFieldByOne :one
UPDATE statistics
SET treasures = treasures + 1
WHERE user_id = $1
RETURNING id, user_id, challenges, events, quests, treasures, longest_streak, tree_grown
`

func (q *Queries) IncreaseTreasuresFieldByOne(ctx context.Context, userID int64) (Statistic, error) {
	row := q.db.QueryRow(ctx, increaseTreasuresFieldByOne, userID)
	var i Statistic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Challenges,
		&i.Events,
		&i.Quests,
		&i.Treasures,
		&i.LongestStreak,
		&i.TreeGrown,
	)
	return i, err
}

const increaseUserPoints = `-- name: IncreaseUserPoints :one
UPDATE profiles
SET points = points + $1
WHERE user_id = $2
RETURNING id, user_id, current_exp, exp_needed, level, points, profile_key
`

type IncreaseUserPointsParams struct {
	Points int64
	UserID int64
}

func (q *Queries) IncreaseUserPoints(ctx context.Context, arg IncreaseUserPointsParams) (Profile, error) {
	row := q.db.QueryRow(ctx, increaseUserPoints, arg.Points, arg.UserID)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrentExp,
		&i.ExpNeeded,
		&i.Level,
		&i.Points,
		&i.ProfileKey,
	)
	return i, err
}

const unlockHabit = `-- name: UnlockHabit :exec
UPDATE habits
SET locked = false
WHERE id = $1
`

func (q *Queries) UnlockHabit(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, unlockHabit, id)
	return err
}

const updaAttendedAt = `-- name: UpdaAttendedAt :exec
UPDATE attendances
SET attended_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) UpdaAttendedAt(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updaAttendedAt, id)
	return err
}

const updateLevelAndExpNeeded = `-- name: UpdateLevelAndExpNeeded :one
UPDATE profiles                                  m
SET exp_needed = $1, level = level + 1
WHERE user_id = $2
RETURNING level
`

type UpdateLevelAndExpNeededParams struct {
	ExpNeeded int64
	UserID    int64
}

func (q *Queries) UpdateLevelAndExpNeeded(ctx context.Context, arg UpdateLevelAndExpNeededParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateLevelAndExpNeeded, arg.ExpNeeded, arg.UserID)
	var level int32
	err := row.Scan(&level)
	return level, err
}

const updateLongestStreak = `-- name: UpdateLongestStreak :exec
UPDATE statistics SET longest_streak = $1
WHERE user_id = $2
`

type UpdateLongestStreakParams struct {
	LongestStreak int32
	UserID        int64
}

func (q *Queries) UpdateLongestStreak(ctx context.Context, arg UpdateLongestStreakParams) error {
	_, err := q.db.Exec(ctx, updateLongestStreak, arg.LongestStreak, arg.UserID)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE profiles
SET profile_key = $1
WHERE user_id = $2
`

type UpdateUserProfileParams struct {
	ProfileKey string
	UserID     int64
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.Exec(ctx, updateUserProfile, arg.ProfileKey, arg.UserID)
	return err
}
